<!DOCTYPE html>
<html>
<head>
    <title>Draw Audio File With d3</title>
<style>

.chart {
  padding: 3px;
  margin: 1px;
}

.axis--grid .domain {
  fill: #ddd;
  stroke: none;
}

.axis--x .domain,
.axis--grid .tick line {
  stroke: #fff;
}

.axis--grid .tick--minor line {
  stroke-opacity: .5;
}

.brush .selection {
	stroke: #000;
	fill: red;
}

</style>
</head>
<body>
    
<!-- https://bost.ocks.org/mike/bar/3/ -->

<svg class="chart"></svg>   

<!--<script src="libs/d3.v3.min.js"></script>-->
<script src="https://d3js.org/d3.v4.min.js"></script>

<script type="text/javascript">

const FIVE_MINUTES_IN_SECONDS = 180;

let data = [];
for( let i = 0; i < FIVE_MINUTES_IN_SECONDS; i ++) {
    data.push(i);
}

var brushes = [];

// settings
var margin = {top: 20, right: 30, bottom: 30, left: 40},
    widthScale = 1200,
    width = widthScale - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom;
    marginBars = 15;


var x = d3.scaleTime()
    .domain([0, (data.length * 1000)]) // segundos a milisegundos...
    .range([0, width + margin.left + margin.right]);

// https://github.com/d3/d3-time-format

var xAxis = d3.axisBottom(x)
    .ticks(d3.timeSecond.every(5))
    .tickPadding([5])
    .tickFormat(d3.timeFormat('%M:%S'));

// get the element chart and set the settings
var chart = d3.select(".chart")
              .attr("width", widthScale + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

chart.append("g")
    .attr("class", "axis axis--grid")
    .attr("transform", "translate(0, " + height + ")")
    .call(d3.axisBottom(x)
        .ticks(d3.timeSecond.every(5))
        .tickSize(-height)
        .tickFormat(function() { return null; }))
    .selectAll(".tick")
        .classed("tick--minor", function(d) { return d.getHours(); });;
    
chart.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x)
            .ticks(d3.timeSecond.every(5))
            .tickPadding([5])
            .tickFormat(d3.timeFormat('%M:%S')));

var gBrushes = chart.append('g')
  .attr("class", "brushes");

function newBrush() {
  var brush = d3.brushX()
    .extent([[0, 0], [width, height]])
    .on("start", brushstart)
    .on("brush", brushed)
    .on("end", brushend);

  brushes.push({id: brushes.length, brush: brush});

  function brushstart() {
    // your stuff here
  };

  function brushed() {
    // your stuff here
  }

  function brushend() {

    // Figure out if our latest brush has a selection
    var lastBrushID = brushes[brushes.length - 1].id;
    var lastBrush = document.getElementById('brush-' + lastBrushID);
    var selection = d3.brushSelection(lastBrush);

    // If it does, that means we need another one
    if (selection && selection[0] !== selection[1]) {
      newBrush();
    }

    // Always draw brushes
    drawBrushes();
  }
}

function drawBrushes() {

  var brushSelection = gBrushes
    .selectAll('.brush')
    .data(brushes, function (d){return d.id});

	// Set up new brushes
  brushSelection.enter()
    .insert("g", '.brush')
    .attr('class', 'brush')
    .attr('id', function(brush){ return "brush-" + brush.id; })
    .each(function(brushObject) {
      //call the brush
      brushObject.brush(d3.select(this));
    });

	/* REMOVE POINTER EVENTS ON BRUSH OVERLAYS
	 *
	 * This part is abbit tricky and requires knowledge of how brushes are implemented.
	 * They register pointer events on a .overlay rectangle within them.
	 * For existing brushes, make sure we disable their pointer events on their overlay.
	 * This frees the overlay for the most current (as of yet with an empty selection) brush to listen for click and drag events
	 * The moving and resizing is done with other parts of the brush, so that will still work.
	 */
  brushSelection
    .each(function (brushObject){
      d3.select(this)
        .attr('class', 'brush')
        .selectAll('.overlay')
        .style('pointer-events', function() {
          var brush = brushObject.brush;
          if (brushObject.id === brushes.length-1 && brush !== undefined) {
            return 'all';
          } else {
            return 'none';
          }
        });
    });

  brushSelection.exit()
    .remove();
}

newBrush();
drawBrushes();

</script>
</body>
</html>